<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="theme-color" content="#6C63FF"/>
    <meta http-equiv="X-UA-Compatible" content="ie=edge"/>
    <meta name="description" content="@kokksha"/>
    <title>SALEM</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Poppins"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/typed.js/2.0.10/typed.min.js"></script>
    <style>
        /* Particle Animation Styles */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000; /* Particle background */
            color: white;
            font-family: 'Courier New', monospace;
            display: flex; /* Use flexbox for centering content */
            flex-direction: column; /* Allow content to stack */
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full height */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: fixed; /* Position canvas as background */
            top: 0;
            left: 0;
            z-index: 1; /* Ensure canvas is behind UI and content */
        }

        #ui {
            position: absolute;
            top: 15px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none; /* Allows clicks to pass through */
        }

        #info {
            font-size: 14px;
            padding: 10px 18px;
            background-color: rgba(25, 30, 50, 0.35);
            border-radius: 10px;
            display: inline-block;
            text-shadow: 0 0 5px rgba(0, 128, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.05);
        }

        #loading {
            position: fixed;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.6s ease-out;
        }

        #loading span {
            font-size: 24px;
            letter-spacing: 2px;
            margin-bottom: 15px;
        }

        #progress-container {
            width: 60%;
            max-width: 300px;
            height: 6px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        #progress {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00a2ff, #00ffea);
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        #controls {
            /* Changed positioning for better integration with content */
            position: relative; /* Changed from absolute */
            bottom: auto; /* Removed bottom positioning */
            left: auto; /* Removed left positioning */
            transform: none; /* Removed transform */
            z-index: 100;
            text-align: center;
            pointer-events: all;
            background-color: transparent;
            padding: 15px 25px;
            border-radius: 12px;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            box-shadow: none;
            margin-top: 30px; /* Added margin to separate from typed text */
        }

        button {
            background: rgba(0, 80, 180, 0.7);
            color: white;
            border: 1px solid rgba(0, 180, 255, 0.6);
            border-radius: 6px;
            padding: 8px 15px;
            margin: 0 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: all 0.25s ease;
        }

        button:hover {
            background: rgba(0, 110, 220, 0.9);
            border-color: rgba(0, 210, 255, 0.9);
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 150, 255, 0.3);
        }

        #color-picker {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 12px;
        }

        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.4);
        }

        .color-option:hover {
            transform: scale(1.15);
            border-color: rgba(255, 255, 255, 0.7);
        }

        .color-option.active {
            transform: scale(1.18);
            border-color: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        }

        /* Direct Content Styles */
        :root {
            --purple: #6C63FF;
            --pink: #FF6B6B;
            --blue: #888888;
        }

        .profile_pic_container {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            margin-top: 50px; /* Adjust as needed for vertical positioning */
            position: relative;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            background-color: black; /* To hide any wave overflow behind the pic */
            overflow: hidden;
            border: 3px solid transparent; /* Add a border for the gradient effect */
            background-image: linear-gradient(to right, var(--purple), var(--pink));
            background-origin: border-box;
            background-clip: content-box, border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none; /* Allow clicks to pass through to canvas */
        }

        .profile_pic {
            width: calc(100% - 6px); /* Account for the border */
            height: calc(100% - 6px); /* Account for the border */
            border-radius: 100%;
            object-fit: cover;
        }

        .text-content {
            text-align: center;
            margin-top: 20px;
            z-index: 10;
            pointer-events: none; /* Allow clicks to pass through to canvas */
        }

        .satan {
            font-weight: 700;
            font-size: 1.4em;
            background: linear-gradient(to right, var(--pink), var(--purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .snuff {
            margin-top: 5px;
            padding: 0 10px;
            background: linear-gradient(to right, var(--pink), var(--purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .typed_text {
            text-align: center;
            min-height: 50px; /* Ensure space for typed text */
        }

        .social {
            padding: 5px;
            margin: 20px auto 0;
            width: fit-content;
        }

        .social div {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px; /* Add spacing between icons */
            flex-wrap: wrap; /* Allow items to wrap to the next line */
        }

        .social a {
            text-decoration: none;
            pointer-events: all; /* Re-enable pointer events for links */
        }

        .social i {
            padding: 10px;
            font-size: 1.2em;
            transition: color 0.3s ease-in-out;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3); /* Add a subtle glow */
        }

        .social i:hover {
            color: white;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8); /* Enhance glow on hover */
        }

        /* Adjusted footer styles */
        .footer-text {
            font-size: 0.75em;
            /* Removed absolute positioning to allow flexbox to control layout */
            /* position: absolute; */
            /* bottom: 15px; */
            width: 100%;
            text-align: center;
            padding: 10px 5px; /* Added some padding for better spacing */
            background: linear-gradient(to right, var(--pink), var(--purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            z-index: 10;
            pointer-events: none;
            margin-top: auto; /* Pushes the item to the bottom in a flex column container */
        }

        .cursor {
            display: inline-block;
            width: 2px;
            background-color: #fff;
            margin-left: 5px;
            animation: continuous-blink 1s infinite alternate;
        }

        @keyframes continuous-blink {
            0% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }
    </style>
</head>
<body>
<div id="loading">
    <span>Initializing Particles...</span>
    <div id="progress-container">
        <div id="progress"></div>
    </div>
</div>

<div id="ui">
    <div id="info">Shape: Sphere (Click to morph)</div>
</div>

<canvas id="webglCanvas"></canvas>

<div class="profile_pic_container">
    <video class="profile_pic" src="https://files.catbox.moe/ap80mh.mp4" autoplay loop muted></video>
</div>

<div class="text-content">
    <div class="satan">
        <h4>SALEM</h4>
    </div>
    <div class="snuff">
        <h5 class="typed_text"><i>Hello World</i><span class="cursor">|</span></h5>
    </div>

    <div id="controls">
        <button id="shape-btn">Change Shape</button>
        <div id="color-picker">
            <div class="color-option" data-scheme="fire" style="background: linear-gradient(to bottom right, #ff4500, #ffcc00)"></div>
            <div class="color-option" data-scheme="neon" style="background: linear-gradient(to bottom right, #ff00ff, #00ffff)"></div>
            <div class="color-option" data-scheme="nature" style="background: linear-gradient(to bottom right, #00ff00, #66ffcc)"></div>
            <div class="color-option" data-scheme="rainbow" style="background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet)"></div>
        </div>
    </div>

    <div class="social">
        <div>
            <a href="https://t.me/kokksha"><i class="fab fa-telegram" style="color: #2AABEE;"></i></a>
            <a href="https://www.facebook.com/share/15KQ2NmX9V/"><i class="fab fa-facebook" style="color: #1877F2;"></i></a>
            <a href="https://www.instagram.com/_u_vf?igsh=bXRqd2Z4ZWhteW94"><i class="fab fa-instagram" style="color: #E1306C;"></i></a>
            <a href="https://github.com/salemalshamrie"><i class="fab fa-github" style="color: #171515;"></i></a>
            <a href="tg://settings"><i class="fas fa-user" style="color: #888888;"></i></a>
            <a href="https://g.co/kgs/pXVXQxK"><i class="fas fa-futbol" style="color: #DB4437;"></i></a>
            <a href="https://uokerbala.edu.iq/"><i class="fas fa-university" style="color: #1976d2;"></i></a>
        </div>
    </div>
</div>
<p class="footer-text"> This page was programmed by Salem Al-Shammari. All rights reserved © 2025. </p>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
            "animejs": "https://cdn.jsdelivr.net/npm/animejs@3.2.2/lib/anime.es.js",
            "simplex-noise": "https://cdn.skypack.dev/simplex-noise@4.0.1"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import anime from 'animejs';
    import { createNoise3D, createNoise4D } from 'simplex-noise';

    let scene, camera, renderer, controls, clock;
    let composer, bloomPass;

    let particlesGeometry, particlesMaterial, particleSystem;
    let currentPositions, sourcePositions, targetPositions, swarmPositions;
    let particleSizes, particleOpacities, particleEffectStrengths;
    let noise3D, noise4D;

    let morphTimeline = null;
    let isInitialized = false;
    let isMorphing = false;
    let initialScaleDone = false; // New flag to track initial scaling

    const CONFIG = {
        particleCount: 15000,
        shapeSize: 14, // Initial size
        swarmDistanceFactor: 1.5,
        swirlFactor: 4.0,
        noiseFrequency: 0.1,
        noiseTimeScale: 0.04,
        noiseMaxStrength: 2.8,
        colorScheme: 'fire',
        morphDuration: 4000,
        particleSizeRange: [0.08, 0.25],
        starCount: 18000,
        bloomStrength: 1.3,
        bloomRadius: 0.5,
        bloomThreshold: 0.05,
        idleFlowStrength: 0.25,
        idleFlowSpeed: 0.08,
        idleRotationSpeed: 0.02,
        morphSizeFactor: 0.5,
        morphBrightnessFactor: 0.6
    };

    const SHAPES = [
        { name: 'Sphere', generator: generateSphere },
        { name: 'Cube', generator: generateCube },
        { name: 'Pyramid', generator: generatePyramid },
        { name: 'Torus', generator: generateTorus },
        { name: 'Galaxy', generator: generateGalaxy },
        { name: 'Wave', generator: generateWave }
    ];
    let currentShapeIndex = 0;

    const morphState = { progress: 0.0 };
    const scaleState = { currentShapeSize: CONFIG.shapeSize }; // Track current shape size for animation

    const COLOR_SCHEMES = {
        fire: { startHue: 0, endHue: 45, saturation: 0.95, lightness: 0.6 },
        neon: { startHue: 300, endHue: 180, saturation: 1.0, lightness: 0.65 },
        nature: { startHue: 90, endHue: 160, saturation: 0.85, lightness: 0.55 },
        rainbow: { startHue: 0, endHue: 360, saturation: 0.9, lightness: 0.6 }
    };

    const tempVec = new THREE.Vector3();
    const sourceVec = new THREE.Vector3();
    const targetVec = new THREE.Vector3();
    const swarmVec = new THREE.Vector3();
    const noiseOffset = new THREE.Vector3();
    const flowVec = new THREE.Vector3();
    const bezPos = new THREE.Vector3();
    const swirlAxis = new THREE.Vector3();
    const currentVec = new THREE.Vector3();

    function generateSphere(count, size) {
        const points = new Float32Array(count * 3);
        const phi = Math.PI * (Math.sqrt(5) - 1);
        for (let i = 0; i < count; i++) {
            const y = 1 - (i / (count - 1)) * 2;
            const radius = Math.sqrt(1 - y * y);
            const theta = phi * i;
            const x = Math.cos(theta) * radius;
            const z = Math.sin(theta) * radius;
            points[i * 3] = x * size;
            points[i * 3 + 1] = y * size;
            points[i * 3 + 2] = z * size;
        }
        return points;
    }

    function generateCube(count, size) {
        const points = new Float32Array(count * 3);
        const halfSize = size / 2;
        for (let i = 0; i < count; i++) {
            const face = Math.floor(Math.random() * 6);
            const u = Math.random() * size - halfSize;
            const v = Math.random() * size - halfSize;
            switch (face) {
                case 0:
                    points.set([halfSize, u, v], i * 3);
                    break;
                case 1:
                    points.set([-halfSize, u, v], i * 3);
                    break;
                case 2:
                    points.set([u, halfSize, v], i * 3);
                    break;
                case 3:
                    points.set([u, -halfSize, v], i * 3);
                    break;
                case 4:
                    points.set([u, v, halfSize], i * 3);
                    break;
                case 5:
                    points.set([u, v, -halfSize], i * 3);
                    break;
            }
        }
        return points;
    }

    function generatePyramid(count, size) {
        const points = new Float32Array(count * 3);
        const halfBase = size / 2;
        const height = size * 1.2;
        const apex = new THREE.Vector3(0, height / 2, 0);
        const baseVertices = [
            new THREE.Vector3(-halfBase, -height / 2, -halfBase),
            new THREE.Vector3(halfBase, -height / 2, -halfBase),
            new THREE.Vector3(halfBase, -height / 2, halfBase),
            new THREE.Vector3(-halfBase, -height / 2, halfBase)
        ];

        const baseArea = size * size;
        const sideFaceHeight = Math.sqrt(Math.pow(height, 2) + Math.pow(halfBase, 2));
        const sideFaceArea = 0.5 * size * sideFaceHeight;
        const totalArea = baseArea + 4 * sideFaceArea;
        const baseWeight = baseArea / totalArea;
        const sideWeight = sideFaceArea / totalArea;

        for (let i = 0; i < count; i++) {
            const r = Math.random();
            let p = new THREE.Vector3();
            let u, v;

            if (r < baseWeight) {
                u = Math.random();
                v = Math.random();
                p.lerpVectors(baseVertices[0], baseVertices[1], u);
                const p2 = new THREE.Vector3().lerpVectors(baseVertices[3], baseVertices[2], u);
                p.lerp(p2, v);
            } else {
                const faceIndex = Math.floor((r - baseWeight) / sideWeight);
                const v1 = baseVertices[faceIndex];
                const v2 = baseVertices[(faceIndex + 1) % 4];
                u = Math.random();
                v = Math.random();
                if (u + v > 1) {
                    u = 1 - u;
                    v = 1 - v;
                }
                p.addVectors(v1, tempVec.subVectors(v2, v1).multiplyScalar(u));
                p.add(tempVec.subVectors(apex, v1).multiplyScalar(v));
            }
            points.set([p.x, p.y, p.z], i * 3);
        }
        return points;
    }

    function generateTorus(count, size) {
        const points = new Float32Array(count * 3);
        const R = size * 0.7;
        const r = size * 0.3;
        for (let i = 0; i < count; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI * 2;

            const x = (R + r * Math.cos(phi)) * Math.cos(theta);
            const y = r * Math.sin(phi);
            const z = (R + r * Math.cos(phi)) * Math.sin(theta);
            points[i * 3] = x;
            points[i * 3 + 1] = y;
            points[i * 3 + 2] = z;
        }
        return points;
    }

    function generateGalaxy(count, size) {
        const points = new Float32Array(count * 3);
        const arms = 4;
        const armWidth = 0.6;
        const bulgeFactor = 0.3;

        for (let i = 0; i < count; i++) {
            const t = Math.pow(Math.random(), 1.5);
            const radius = t * size;

            const armIndex = Math.floor(Math.random() * arms);
            const armOffset = (armIndex / arms) * Math.PI * 2;

            const rotationAmount = radius / size * 6; // Spiral effect
            const angle = armOffset + rotationAmount;

            const spread = (Math.random() - 0.5) * armWidth * (1 - radius / size); // Wider at center

            const theta = angle + spread;
            const x = radius * Math.cos(theta);
            const z = radius * Math.sin(theta);
            const y = (Math.random() - 0.5) * size * 0.1 * (1 - radius / size * bulgeFactor); // Thicker at center

            points[i * 3] = x;
            points[i * 3 + 1] = y;
            points[i * 3 + 2] = z;
        }
        return points;
    }

    function generateWave(count, size) {
        const points = new Float32Array(count * 3);
        const waveScale = size * 0.4;
        const frequency = 3;

        for (let i = 0; i < count; i++) {
            const u = Math.random() * 2 - 1; // -1 to 1
            const v = Math.random() * 2 - 1; // -1 to 1

            const x = u * size;
            const z = v * size;

            const dist = Math.sqrt(u * u + v * v); // Distance from center
            const angle = Math.atan2(v, u); // Angle around center

            // Create a wave based on distance and angle
            const y = Math.sin(dist * Math.PI * frequency) * Math.cos(angle * 2) * waveScale * (1 - dist); // (1-dist) makes wave smaller at edges

            points[i * 3] = x;
            points[i * 3 + 1] = y;
            points[i * 3 + 2] = z;
        }
        return points;
    }

    function init() {
        let progress = 0;
        const progressBar = document.getElementById('progress');
        const loadingScreen = document.getElementById('loading');

        function updateProgress(increment) {
            progress += increment;
            progressBar.style.width = `${Math.min(100, progress)}%`;
            if (progress >= 100) {
                setTimeout(() => {
                    loadingScreen.style.opacity = '0';
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        // Trigger initial scale after loading and hide animation
                        setTimeout(triggerInitialScale, 5000); // 5-second delay
                    }, 600);
                }, 200);
            }
        }

        clock = new THREE.Clock();
        noise3D = createNoise3D(() => Math.random());
        noise4D = createNoise4D(() => Math.random());

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000308, 0.03);
        updateProgress(5);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 28);
        camera.lookAt(scene.position);
        updateProgress(5);

        const canvas = document.getElementById('webglCanvas');
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true, powerPreference: 'high-performance' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        updateProgress(10);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 80;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.3;
        updateProgress(5);

        scene.add(new THREE.AmbientLight(0x404060));
        const dirLight1 = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight1.position.set(15, 20, 10);
        scene.add(dirLight1);
        const dirLight2 = new THREE.DirectionalLight(0x88aaff, 0.9);
        dirLight2.position.set(-15, -10, -15);
        scene.add(dirLight2);
        updateProgress(10);

        setupPostProcessing();
        updateProgress(10);

        createStarfield();
        updateProgress(15);

        setupParticleSystem();
        updateProgress(25);

        window.addEventListener('resize', onWindowResize);
        window.addEventListener('click', onCanvasClick);
        document.getElementById('shape-btn').addEventListener('click', triggerMorph);
        document.querySelectorAll('.color-option').forEach(option => {
            option.addEventListener('click', (e) => {
                document.querySelectorAll('.color-option').forEach(o => o.classList.remove('active'));
                e.target.classList.add('active');
                CONFIG.colorScheme = e.target.dataset.scheme;
                updateColors();
            });
        });
        document.querySelector(`.color-option[data-scheme="${CONFIG.colorScheme}"]`).classList.add('active');
        updateProgress(15);

        isInitialized = true;
        animate();
        console.log("Initialization complete.");
    }

    function setupPostProcessing() {
        composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), CONFIG.bloomStrength, CONFIG.bloomRadius, CONFIG.bloomThreshold);
        composer.addPass(bloomPass);
    }

    function createStarfield() {
        const starVertices = [];
        const starSizes = [];
        const starColors = [];
        const starGeometry = new THREE.BufferGeometry();

        for (let i = 0; i < CONFIG.starCount; i++) {
            tempVec.set(
                THREE.MathUtils.randFloatSpread(400),
                THREE.MathUtils.randFloatSpread(400),
                THREE.MathUtils.randFloatSpread(400)
            );
            // Ensure stars are far away
            if (tempVec.length() < 100) tempVec.setLength(100 + Math.random() * 300);

            starVertices.push(tempVec.x, tempVec.y, tempVec.z);
            starSizes.push(Math.random() * 0.15 + 0.05);

            const color = new THREE.Color();
            if (Math.random() < 0.1) { // Some stars with random hues
                color.setHSL(Math.random(), 0.7, 0.65);
            } else { // Mostly blue/white stars
                color.setHSL(0.6, Math.random() * 0.1, 0.8 + Math.random() * 0.2);
            }
            starColors.push(color.r, color.g, color.b);
        }

        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        starGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));

        const starMaterial = new THREE.ShaderMaterial({
            uniforms: {
                pointTexture: { value: createStarTexture() }
            },
            vertexShader: `
                attribute float size;
                varying vec3 vColor;
                varying float vSize;

                void main() {
                    vColor = color;
                    vSize = size;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * (400.0 / -mvPosition.z); // Size attenuation
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D pointTexture;
                varying vec3 vColor;
                varying float vSize;

                void main() {
                    float alpha = texture2D(pointTexture, gl_PointCoord).a;
                    if (alpha < 0.1) discard; // Discard pixels with low alpha

                    gl_FragColor = vec4(vColor, alpha * 0.9);
                }
            `,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            vertexColors: true
        });

        scene.add(new THREE.Points(starGeometry, starMaterial));
    }

    function createStarTexture() {
        const size = 64;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
        gradient.addColorStop(0.5, 'rgba(255,255,255,0.3)');
        gradient.addColorStop(1, 'rgba(255,255,255,0)');
        context.fillStyle = gradient;
        context.fillRect(0, 0, size, size);
        return new THREE.CanvasTexture(canvas);
    }

    function setupParticleSystem() {
        // Pre-generate all target shape positions
        // This will be regenerated after initial scale
        targetPositions = SHAPES.map(shape => shape.generator(CONFIG.particleCount, CONFIG.shapeSize));

        particlesGeometry = new THREE.BufferGeometry();

        // Initialize with the first shape's positions
        currentPositions = new Float32Array(targetPositions[0]);
        sourcePositions = new Float32Array(targetPositions[0]); // Start from same position
        swarmPositions = new Float32Array(CONFIG.particleCount * 3); // For Bezier control point

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));

        particleSizes = new Float32Array(CONFIG.particleCount);
        particleOpacities = new Float32Array(CONFIG.particleCount);
        particleEffectStrengths = new Float32Array(CONFIG.particleCount); // For morphing effects
        for (let i = 0; i < CONFIG.particleCount; i++) {
            particleSizes[i] = THREE.MathUtils.randFloat(CONFIG.particleSizeRange[0], CONFIG.particleSizeRange[1]);
            particleOpacities[i] = 1.0;
            particleEffectStrengths[i] = 0.0;
        }
        particlesGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
        particlesGeometry.setAttribute('opacity', new THREE.BufferAttribute(particleOpacities, 1));
        particlesGeometry.setAttribute('aEffectStrength', new THREE.BufferAttribute(particleEffectStrengths, 1));

        const colors = new Float32Array(CONFIG.particleCount * 3);
        updateColorArray(colors, currentPositions); // Initial colors
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));


        particlesMaterial = new THREE.ShaderMaterial({
            uniforms: {
                pointTexture: { value: createStarTexture() }
            },
            vertexShader: `
                attribute float size;
                attribute float opacity;
                attribute float aEffectStrength; // 0 during idle, 1 during peak morph
                varying vec3 vColor;
                varying float vOpacity;
                varying float vEffectStrength;

                void main() {
                    vColor = color;
                    vOpacity = opacity;
                    vEffectStrength = aEffectStrength;

                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

                    // Reduce size during morph for "implosion" effect
                    float sizeScale = 1.0 - vEffectStrength * ${CONFIG.morphSizeFactor.toFixed(2)};
                    gl_PointSize = size * sizeScale * (400.0 / -mvPosition.z);

                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D pointTexture;
                varying vec3 vColor;
                varying float vOpacity;
                varying float vEffectStrength;

                void main() {
                    float alpha = texture2D(pointTexture, gl_PointCoord).a;
                    if (alpha < 0.05) discard; // Remove transparent parts

                    // Increase brightness during morph
                    vec3 finalColor = vColor * (1.0 + vEffectStrength * ${CONFIG.morphBrightnessFactor.toFixed(2)});

                    gl_FragColor = vec4(finalColor, alpha * vOpacity);
                }
            `,
            blending: THREE.AdditiveBlending,
            depthTest: true, // Particles closer to camera obscure farther ones
            depthWrite: false, // Prevents particles from writing to depth buffer, which can cause artifacts
            transparent: true,
            vertexColors: true
        });

        particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particleSystem);
    }

    function updateColorArray(colors, positionsArray) {
        const colorScheme = COLOR_SCHEMES[CONFIG.colorScheme];
        const center = new THREE.Vector3(0, 0, 0); // Assuming shapes are centered
        const maxRadius = CONFIG.shapeSize * 1.1; // Max expected distance from center

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;
            tempVec.fromArray(positionsArray, i3);
            const dist = tempVec.distanceTo(center);

            let hue;
            if (CONFIG.colorScheme === 'rainbow') {
                // Map position to a hue for rainbow effect
                const normX = (tempVec.x / maxRadius + 1) / 2; // Normalize x to 0-1
                const normY = (tempVec.y / maxRadius + 1) / 2; // Normalize y to 0-1
                const normZ = (tempVec.z / maxRadius + 1) / 2; // Normalize z to 0-1
                hue = (normX * 120 + normY * 120 + normZ * 120) % 360; // Simple XYZ based hue
            } else {
                hue = THREE.MathUtils.mapLinear(
                    dist,
                    0,
                    maxRadius,
                    colorScheme.startHue,
                    colorScheme.endHue
                );
            }

            // Add some noise to saturation and lightness for variation
            const noiseValue = (noise3D(tempVec.x * 0.2, tempVec.y * 0.2, tempVec.z * 0.2) + 1) * 0.5; // 0 to 1
            const saturation = THREE.MathUtils.clamp(colorScheme.saturation * (0.9 + noiseValue * 0.2), 0, 1);
            const lightness = THREE.MathUtils.clamp(colorScheme.lightness * (0.85 + noiseValue * 0.3), 0.1, 0.9);

            const color = new THREE.Color().setHSL(hue / 360, saturation, lightness);
            color.toArray(colors, i3);
        }
    }

    function updateColors() {
        const colors = particlesGeometry.attributes.color.array;
        updateColorArray(colors, particlesGeometry.attributes.position.array);
        particlesGeometry.attributes.color.needsUpdate = true;
    }

    // New function to handle initial scaling
    function triggerInitialScale() {
        if (initialScaleDone || isMorphing) return; // Prevent multiple calls or scaling during another morph
        initialScaleDone = true;
        controls.autoRotate = false; // Stop auto-rotation during scale

        console.log("Initiating initial scale (100%)..."); // Updated console log
        document.getElementById('info').innerText = `Scaling...`;
        document.getElementById('info').style.textShadow = '0 0 8px rgba(255, 150, 50, 0.9)';

        // Store current positions as source
        sourcePositions.set(currentPositions);

        // Update CONFIG.shapeSize directly to the target scale
        const targetShapeSize = CONFIG.shapeSize; // 100% (original size) - THIS IS THE CHANGE

        // Regenerate all target positions with the new CONFIG.shapeSize
        const newTargetPositions = SHAPES.map(shape => shape.generator(CONFIG.particleCount, targetShapeSize));
        // Find the specific target positions for the current shape
        const currentShapeTargetPositions = newTargetPositions[currentShapeIndex];

        // Animate the scaleState.currentShapeSize to trigger the morph to the larger shape
        anime({
            targets: scaleState,
            currentShapeSize: targetShapeSize,
            duration: CONFIG.morphDuration, // Use the same morph duration for consistency
            easing: 'cubicBezier(0.4, 0.0, 0.2, 1.0)',
            update: () => {
                // Calculate the intermediate target positions based on scaleState.currentShapeSize
                // This is a simplified way to "morph" to a larger version of the same shape
                // We recreate current shape positions scaled by the current animation progress
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const i3 = i * 3;
                    // Scale the original initial positions to the current size during animation
                    // This creates the visual scaling effect
                    sourceVec.fromArray(targetPositions[currentShapeIndex], i3); // Use original initial shape points
                    tempVec.copy(sourceVec).multiplyScalar(scaleState.currentShapeSize / CONFIG.shapeSize);

                    // For the bezier curve, we still need the intermediate "swarm" point
                    // This is a bit tricky for pure scaling, we can simplify for this initial scale.
                    // A more accurate scaling would involve recalculating swarm positions, but it's complex for just scale.
                    // So we'll just directly update the currentPositions based on the scaled target.
                    currentPositions[i3] = tempVec.x;
                    currentPositions[i3 + 1] = tempVec.y;
                    currentPositions[i3 + 2] = tempVec.z;
                }
                particlesGeometry.attributes.position.needsUpdate = true;
                // Also update the effect strength for visual feedback during scaling
                const effectStrength = Math.sin(anime.get(scaleState, 'progress', 'as-percent') * Math.PI / 100); // 0 -> 1 -> 0
                for (let i = 0; i < CONFIG.particleCount; i++) {
                     particleEffectStrengths[i] = effectStrength;
                }
                particlesGeometry.attributes.aEffectStrength.needsUpdate = true;
            },
            complete: () => {
                CONFIG.shapeSize = targetShapeSize; // Update CONFIG.shapeSize permanently
                console.log(`Initial scale complete. New shapeSize: ${CONFIG.shapeSize}`);
                document.getElementById('info').innerText = `Shape: ${SHAPES[currentShapeIndex].name} (Click to morph)`;
                document.getElementById('info').style.textShadow = '0 0 5px rgba(0, 128, 255, 0.8)';

                // Regenerate ALL target positions with the NEW CONFIG.shapeSize
                targetPositions = SHAPES.map(shape => shape.generator(CONFIG.particleCount, CONFIG.shapeSize));
                sourcePositions.set(targetPositions[currentShapeIndex]); // Reset source for future morphs
                updateColors(); // Recalculate colors based on new positions

                // Reset effect strength
                particleEffectStrengths.fill(0.0);
                particlesGeometry.attributes.aEffectStrength.needsUpdate = true;

                isMorphing = false; // Important: ensure morphing state is reset
                controls.autoRotate = true; // Resume auto-rotation
            }
        });

        isMorphing = true; // Set morphing to true during the initial scale to prevent other morphs
    }


    function triggerMorph() {
        if (isMorphing) return; // Prevent new morph if already morphing
        isMorphing = true;
        controls.autoRotate = false; // Stop auto-rotation during morph

        console.log("Morphing triggered...");
        document.getElementById('info').innerText = `Morphing...`;
        document.getElementById('info').style.textShadow = '0 0 8px rgba(255, 150, 50, 0.9)'; // Orange glow for morphing state


        sourcePositions.set(currentPositions); // Current state is the source

        const nextShapeIndex = (currentShapeIndex + 1) % SHAPES.length;
        const nextTargetPositions = targetPositions[nextShapeIndex]; // Use already generated target positions

        // Calculate swarm control points for Bezier curve
        const centerOffsetAmount = CONFIG.shapeSize * CONFIG.swarmDistanceFactor;
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;
            sourceVec.fromArray(sourcePositions, i3);
            targetVec.fromArray(nextTargetPositions, i3);

            // Swarm point is midway between source and target, with an outward random offset
            swarmVec.lerpVectors(sourceVec, targetVec, 0.5);

            // Add a noisy, outward direction to the swarm point
            const offsetDir = tempVec.set(
                noise3D(i * 0.05, 10, 10),
                noise3D(20, i * 0.05, 20),
                noise3D(30, 30, i * 0.05)
            ).normalize();

            // The distance factor for the swarm point can be related to the distance between start/end points
            const distFactor = sourceVec.distanceTo(targetVec) * 0.1 + centerOffsetAmount; // Adjust based on shape size and random factor
            swarmVec.addScaledVector(offsetDir, distFactor * (0.5 + Math.random() * 0.8)); // Randomize offset strength

            swarmPositions[i3] = swarmVec.x;
            swarmPositions[i3 + 1] = swarmVec.y;
            swarmPositions[i3 + 2] = swarmVec.z;
        }

        currentShapeIndex = nextShapeIndex;

        // Reset morph progress and start animation
        morphState.progress = 0;
        if (morphTimeline) morphTimeline.pause(); // Stop any ongoing animation

        morphTimeline = anime({
            targets: morphState,
            progress: 1, // Animate progress from 0 to 1
            duration: CONFIG.morphDuration,
            easing: 'cubicBezier(0.4, 0.0, 0.2, 1.0)', // Accelerate then decelerate
            complete: () => {
                console.log("Morphing complete.");
                document.getElementById('info').innerText = `Shape: ${SHAPES[currentShapeIndex].name} (Click to morph)`;
                document.getElementById('info').style.textShadow = '0 0 5px rgba(0, 128, 255, 0.8)'; // Restore blue glow

                // Snap particles to final target positions at the end of morph
                currentPositions.set(targetPositions[currentShapeIndex]);
                particlesGeometry.attributes.position.needsUpdate = true;

                // Reset effect strength
                particleEffectStrengths.fill(0.0);
                particlesGeometry.attributes.aEffectStrength.needsUpdate = true;

                // Set new source positions for the next morph/idle animation
                sourcePositions.set(targetPositions[currentShapeIndex]);
                updateColors(); // Update colors for the new shape

                isMorphing = false;
                controls.autoRotate = true; // Resume auto-rotation
            }
        });
    }

    function animate() {
        requestAnimationFrame(animate);

        if (!isInitialized) return; // Wait until everything is loaded

        const elapsedTime = clock.getElapsedTime();
        const deltaTime = clock.getDelta();

        controls.update();

        const positions = particlesGeometry.attributes.position.array;
        const effectStrengths = particlesGeometry.attributes.aEffectStrength.array;


        if (isMorphing) {
            updateMorphAnimation(positions, effectStrengths, elapsedTime, deltaTime);
        } else {
            updateIdleAnimation(positions, effectStrengths, elapsedTime, deltaTime);
        }

        particlesGeometry.attributes.position.needsUpdate = true;
        // Only update effectStrength attribute if it changed (during morph or just after)
        if (isMorphing || particlesGeometry.attributes.aEffectStrength.needsUpdate) {
            particlesGeometry.attributes.aEffectStrength.needsUpdate = true;
        }

        composer.render(deltaTime);
    }

    function updateMorphAnimation(positions, effectStrengths, elapsedTime, deltaTime) {
        const t = morphState.progress; // Normalized progress (0 to 1)
        const targets = targetPositions[currentShapeIndex];

        // Effect strength for size/brightness changes peaks mid-morph
        const effectStrength = Math.sin(t * Math.PI); // Goes from 0 -> 1 -> 0

        // Swirl and noise strength vary with morph progress
        const currentSwirl = effectStrength * CONFIG.swirlFactor * deltaTime * 50;
        const currentNoise = effectStrength * CONFIG.noiseMaxStrength;


        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;
            sourceVec.fromArray(sourcePositions, i3);
            swarmVec.fromArray(swarmPositions, i3);
            targetVec.fromArray(targets, i3);

            // Calculate position using a quadratic Bezier curve
            // P(t) = (1-t)^2 * P0 + 2(1-t)t * P1 + t^2 * P2
            const t_inv = 1.0 - t;
            const t_inv_sq = t_inv * t_inv;
            const t_sq = t * t;

            bezPos.copy(sourceVec).multiplyScalar(t_inv_sq);
            bezPos.addScaledVector(swarmVec, 2.0 * t_inv * t);
            bezPos.addScaledVector(targetVec, t_sq);


            // Apply swirl effect during morph
            if (currentSwirl > 0.01) {
                tempVec.subVectors(bezPos, sourceVec); // Vector from source to current bezier point
                // Randomize swirl axis per particle using noise
                swirlAxis.set(
                    noise3D(i * 0.02, elapsedTime * 0.1, 0),
                    noise3D(0, i * 0.02, elapsedTime * 0.1 + 5),
                    noise3D(elapsedTime * 0.1 + 10, 0, i * 0.02)
                ).normalize();
                tempVec.applyAxisAngle(swirlAxis, currentSwirl * (0.5 + Math.random() * 0.5)); // Randomize swirl intensity per particle
                bezPos.copy(sourceVec).add(tempVec); // Re-add to source position
            }

            // Apply noise displacement during morph
            if (currentNoise > 0.01) {
                const noiseTime = elapsedTime * CONFIG.noiseTimeScale;
                noiseOffset.set(
                    noise4D(bezPos.x * CONFIG.noiseFrequency, bezPos.y * CONFIG.noiseFrequency, bezPos.z * CONFIG.noiseFrequency, noiseTime),
                    noise4D(bezPos.x * CONFIG.noiseFrequency + 100, bezPos.y * CONFIG.noiseFrequency + 100, bezPos.z * CONFIG.noiseFrequency + 100, noiseTime),
                    noise4D(bezPos.x * CONFIG.noiseFrequency + 200, bezPos.y * CONFIG.noiseFrequency + 200, bezPos.z * CONFIG.noiseFrequency + 200, noiseTime)
                );
                bezPos.addScaledVector(noiseOffset, currentNoise);
            }


            positions[i3] = bezPos.x;
            positions[i3 + 1] = bezPos.y;
            positions[i3 + 2] = bezPos.z;

            effectStrengths[i] = effectStrength; // Pass to shader for visual effects
        }
        particlesGeometry.attributes.aEffectStrength.needsUpdate = true; // Mark as needing update
    }

    function updateIdleAnimation(positions, effectStrengths, elapsedTime, deltaTime) {
        // Subtle "breathing" scale
        const breathScale = 1.0 + Math.sin(elapsedTime * 0.5) * 0.015;
        const timeScaled = elapsedTime * CONFIG.idleFlowSpeed;
        const freq = 0.1;

        let needsEffectStrengthReset = false; // Flag to only update if needed

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;
            sourceVec.fromArray(sourcePositions, i3);

            // Apply breathing
            tempVec.copy(sourceVec).multiplyScalar(breathScale);

            // Apply gentle flow using 4D noise (3D position + time)
            flowVec.set(
                noise4D(tempVec.x * freq, tempVec.y * freq, tempVec.z * freq, timeScaled),
                noise4D(tempVec.x * freq + 10, tempVec.y * freq + 10, tempVec.z * freq + 10, timeScaled),
                noise4D(tempVec.x * freq + 20, tempVec.y * freq + 20, tempVec.z * freq + 20, timeScaled)
            );
            tempVec.addScaledVector(flowVec, CONFIG.idleFlowStrength);

            // Smoothly interpolate towards the desired idle position
            currentVec.fromArray(positions, i3);
            currentVec.lerp(tempVec, 0.05); // Smooth interpolation
            positions[i3] = currentVec.x;
            positions[i3 + 1] = currentVec.y;
            positions[i3 + 2] = currentVec.z;

            // Ensure effect strength is 0 during idle
            if (effectStrengths[i] !== 0.0) {
                effectStrengths[i] = 0.0;
                needsEffectStrengthReset = true;
            }
        }
        if (needsEffectStrengthReset) {
            particlesGeometry.attributes.aEffectStrength.needsUpdate = true;
        }
    }


    function onCanvasClick(event) {
        // Prevent morphing when clicking on UI elements (like controls or specifically enabled links/buttons)
        if (event.target.closest('#controls') || event.target.closest('.social a')) {
            return;
        }
        triggerMorph();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    init();

</script>
<script>
    // Typed.js Script
    var options = {
        strings: ["<i>First Sentence</i>.", "BELIEVE IN YOURSELF, NOTHING IS IMPOSSIBLE.<br>Telegram Channel: @kokksha<br>Instagram: @_u_vf"],
        typeSpeed: 7
    };
    var typed = new Typed(".typed_text", options);
</script>
</body>
</html>
